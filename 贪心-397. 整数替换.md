
## 题目地址(397. 整数替换)

[https://leetcode-cn.com/problems/integer-replacement/](https://leetcode-cn.com/problems/integer-replacement/)

## 题目描述


给定一个正整数 n ，你可以做如下操作：

如果 n 是偶数，则用 n / 2替换 n 。
如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。

n 变为 1 所需的最小替换次数是多少？

 

示例 1：
```
输入：n = 8
输出：3
解释：8 -> 4 -> 2 -> 1
```

示例 2：
```
输入：n = 7
输出：4
解释：7 -> 8 -> 4 -> 2 -> 1
或 7 -> 6 -> 3 -> 2 -> 1
```

示例 3：
```
输入：n = 4
输出：2
```

 

提示：

1 <= n <= 2^31 - 1

## 时间

- 2021年11月19日

## 难度

- 中等
- 递归思路容易想，但是容易写错，容易越界；
- 贪心思路难想到

## 思路

### 方法一：枚举所有的情况

我们可以使用递归的方法枚举所有将 n 变为 1 的替换序列：

- 当 n 为偶数时，我们只有唯一的方法将 n 替换为 n / 2。

- 当 n 为奇数时，我们可以选择将 n 增加 1 或减少 1。由于这两种方法都会将 n 变为偶数，那么下一步一定是除以 2，因此这里我们可以看成使用两次操作，将 n 变为 (n+1)/2 或 (n−1)/2。

**细节**

当 n = 2^31-1 时，计算 n+1 会导致溢出，因此我们可以使用整数除法 ⌊ n / 2 ⌋+1 和 ⌊ n / 2 ⌋ 分别计算 (n+1)/2 或 (n+1)/2  ，其中 ⌊⋅⌋ 表示向下取整。

**Java Code:**

```java
class Solution {
    public int integerReplacement(int n) {
        if (n == 1) {
            return 0;
        }
        if (n % 2 == 0) {
            return 1 + integerReplacement(n / 2);
        }
        return 2 + Math.min(integerReplacement(n / 2), integerReplacement(n / 2 + 1));
    }
}
```

**复杂度分析**

- 时间复杂度：O(ϕ ^logn)，其中 ϕ= (1 + sqrt(5)) / 2 ≈1.618 表示黄金分割比。

时间复杂度的准确证明较为复杂，这里给出一种直观上的叙述，感兴趣的读者可以自行展开思考：

- 在递归的过程中，递归树的同一层上最小的 n 值和最大的 n 值相差不会超过 1，这里可以使用数学归纳法证明。

- 如果递归树的上一层出现的值为 x 和 x+1，它们分别被递归调用了 p 和 q 次，而当前层出现的值为 y 和 y+1，那么它们分别会被递归调用：

    - 要么 p 和 p+q 次；

    - 要么 p+q 和 q 次。

这类似于斐波那契数列的递推式。

因此 l = O(logn) 层的递归树中所有 n 值被调用的次数之和为 O(fib(l))=O(fib(logn))，其中 fib(⋅) 表示斐波那契数列的对应项。由于 fib(l)=O(ϕ ^l)，因此算法的时间复杂度为 O(ϕ ^logn)。

- 空间复杂度：O(logn)。每一次递归都会将 n 减小一半，因此需要 O(logn) 的栈空间。

### 方法二：记忆化搜索

我们给方法一的递归加上记忆化，这样递归树的每一层最多只会计算两个 n 值，时间复杂度降低为 O(logn)。

**Java Code:**

```java
class Solution {
    Map<Integer, Integer> memo = new HashMap<Integer, Integer>();

    public int integerReplacement(int n) {
        if (n == 1) {
            return 0;
        }
        if (!memo.containsKey(n)) {
            if (n % 2 == 0) {
                memo.put(n, 1 + integerReplacement(n / 2));
            } else {
                memo.put(n, 2 + Math.min(integerReplacement(n / 2), integerReplacement(n / 2 + 1)));
            }
        }
        return memo.get(n);
    }
}
```

**复杂度分析**

- 时间复杂度：O(logn)。

- 空间复杂度：O(logn)。记忆化搜索需要的空间与栈空间相同，同样为  O(logn) 。

### 方法三：贪心

实际上，方法一和方法二中的递归枚举中的「最优解」是固定的：

- 当 n 为偶数时，我们只有唯一的方法将 n 替换为 n / 2 ；

- 当 n 为奇数时，n 除以 4 的余数要么为 1，要么为 3。

    - 如果为 1，我们可以断定，应该将 n 变成 (n−1)/2。因为如果将 n 变成 (n+1)/2，而  (n+1)/2 是奇数，那么：

        - 如果下一步进行 -1 再除以 2，得到 (n−1)/4 ，那么从  (n−1)/2 可以除以 2 一次操作得到同样的结果；

        - 如果下一步进行 +1 再除以 2，得到  (n+3)/4，那么从 (n−1)/2 可以除以 2 再 +1 两次操作得到同样的结果。

        - 因此将 n 变成 (n−1)/2 总是不会劣于 (n+1)/2。

    - 如果为 3，我们可以断定，应该将 n 变成 (n+1)/2。因为如果将 n 变成 (n−1)/2，而 (n−1)/2 是奇数，那么：

        - 如果下一步进行 -1 再除以 2，得到 (n−3)/4 ，那么从  (n+1)/2 可以除以 2 再 -1 两次操作得到同样的结果；

        - 如果下一步进行 +1 再除以 2，得到  (n+1)/4，那么从 (n+1)/2 可以除以 2 一次操作得到同样的结果。

        - 因此将 n 变成 (n+1)/2 总是不会劣于 (n-1)/2。但这里还需要考虑一种例外的情况，如果 (n−1)/2 已经为 1，即 n=3 时，后续就无需再进行任何操作，此时将 n 变成 (n−1)/2 才是最优的。

因此，我们只需要根据上面的分类讨论，求出将 n 变为 1 的操作次数即可。


```java

class Solution {
    public int integerReplacement(int n) {
        int ans = 0;
        while (n != 1) {
            if (n % 2 == 0) {
                ++ans;
                n /= 2;
            } else if (n % 4 == 1) {
                ans += 2;
                n /= 2;
            } else {
                if (n == 3) {
                    ans += 2;
                    n = 1;
                } else {
                    ans += 2;
                    n = n / 2 + 1;
                }
            }
        }
        return ans;
    }
}

```

**复杂度分析**

- 时间复杂度：O(logn)。

- 空间复杂度：O(1)。
