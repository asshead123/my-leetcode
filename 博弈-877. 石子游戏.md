
## 题目地址(877. 石子游戏)

https://leetcode-cn.com/problems/stone-game/

## 题目描述

```
亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。

 

示例：

输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。


 

提示：

2 <= piles.length <= 500
piles.length 是偶数。
1 <= piles[i] <= 500
sum(piles) 是奇数。
```

## 时间

- 2021年9月14日

## 难度

- 中等

## 思路

### 方法一：数学
错误解法：每次简单地挑数字大的堆选。

错误原因：如 piles=[2, 1, 9, 5]，如果每次都挑选数字大的，那么取的顺序就是 5（你）-9（Lee）-2（你）-1（Lee），你最终得分7，而 Lee 得分10，你输了。

原因在于你一开始取5把更大的9暴露给了Lee，如果你一开始取得是2，那么Lee就会把9暴露给你，取的顺序就是 2（你）-5（Lee）-9（你）-1（Lee），你最终得分11，而 Lee 得分6，那么你就能赢。

因此该游戏并不是简单的每次挑数字大的堆选。

正确做法：

由于石子的堆数为偶数，对于先手而言：每一次的决策局面，都能「自由地」选择奇数还是偶数的序列，从而限制后手下一次「只能」奇数还是偶数石子。

具体的，对于本题，由于石子堆数为偶数，因此先手的最开始局面必然是 [奇数, 偶数][奇数,偶数]，即必然是「奇偶性不同的局面」；当先手决策完之后，交到给后手的要么是 [奇数,奇数][奇数,奇数] 或者 [偶数,偶数][偶数,偶数]，即必然是「奇偶性相同的局面」；后手决策完后，又恢复「奇偶性不同的局面」交回到先手 ...

不难归纳推理，这个边界是可以应用到每一个回合。

因此先手只需要在进行第一次操作前计算原序列中「奇数总和」和「偶数总和」哪个大，然后每一次决策都「限制」对方只能选择「最优奇偶性序列」的对立面即可。

同时又由于所有石子总和为奇数，堆数为偶数，即没有平局，所以先手必胜。


**Java Code**

```java

class Solution {
    public boolean stoneGame(int[] piles) {
        return true;
    }
}

```


**复杂度分析**

- 时间复杂度：O(1)。
- 空间复杂度：O(1)。

### 方法二：动态规划
用动态规划可以解决更一般化的博弈问题，比如本题如果石头堆数任意，每堆的石头数也任意，每个人只能从石头堆的最左边或者最右边拿走一堆，这就是一般性的博弈问题了。如 piles = [1, 100, 3]，那么不能保证先手必赢。下面是一般性博弈问题的解法。

由于每次只能从行的开始或结束处取走整堆石子，因此可以保证剩下的石子堆一定是连续的。

如果只剩下一堆石子，则当前玩家只能取走这堆石子。如果剩下多堆石子，则当前玩家可以选择从行的开始或结束处取走整堆石子，然后轮到另一个玩家在剩下的石子堆中取走石子。这是一个递归的过程，因此可以使用递归进行求解，递归过程中维护一个总数，表示 Alex 和 Lee 的石子数量之差，当游戏结束时，如果总数大于 0，则 Alex 赢得比赛，否则 Lee 赢得比赛。

如果有 n 堆石子，则递归的时间复杂度为 O(2^n)，无法通过所有的测试用例。递归的时间复杂度高的原因是存在大量重复计算。由于存在重复子问题，因此可以使用动态规划降低时间复杂度。

定义二维数组 dp，其行数和列数都等于石子的堆数，dp[i][j] 表示当剩下的石子堆为下标 i 到下标 j 时，即在下标范围 [i, j] 中，当前玩家与另一个玩家的石子数量之差的最大值，注意当前玩家不一定是先手 Alex。

只有当 i ≤ j 时，剩下的石子堆才有意义，因此当 i>j 时，dp[i][j]=0。

当 i=j 时，只剩下一堆石子，当前玩家只能取走这堆石子，因此对于所有 0≤i<nums.length，都有dp[i][i]=piles[i]。

当 i<j 时，当前玩家可以选择取走 piles[i] 或 piles[j]，然后轮到另一个玩家在剩下的石子堆中取走石子。在两种方案中，当前玩家会选择最优的方案，使得自己的石子数量最大化。因此可以得到如下状态转移方程：

dp[i][j]=max(piles[i]−dp[i+1][j],piles[j]−dp[i][j−1])

最后判断 dp[0][piles.length−1] 的值，如果大于 0，则 Alex 的石子数量大于 Lee 的石子数量，因此 Alex 赢得比赛，否则 Lee 赢得比赛。

**Java Code**
```java
class Solution {
    public boolean stoneGame(int[] piles) {
        int length = piles.length;
        int[][] dp = new int[length][length];
        for (int i = 0; i < length; i++) {
            dp[i][i] = piles[i];
        }
        for (int i = length - 2; i >= 0; i--) {
            for (int j = i + 1; j < length; j++) {
                dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
            }
        }
        return dp[0][length - 1] > 0;
    }
}
```
上述代码中使用了二维数组 dp。分析状态转移方程可以看到，dp[i][j] 的值只和 dp[i+1][j] 与 dp[i][j−1] 有关，即在计算 dp 的第 i 行的值时，只需要使用到 dp 的第 i 行和第 i+1 行的值，因此可以使用一维数组代替二维数组，对空间进行优化。

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        int length = piles.length;
        int[] dp = new int[length];
        for (int i = 0; i < length; i++) {
            dp[i] = piles[i];
        }
        for (int i = length - 2; i >= 0; i--) {
            for (int j = i + 1; j < length; j++) {
                dp[j] = Math.max(piles[i] - dp[j], piles[j] - dp[j - 1]);
            }
        }
        return dp[length - 1] > 0;
    }
}
```

**复杂度分析**

- 时间复杂度：O(n^2)，其中 n 是数组的长度。需要计算每个子数组对应的 dp 的值，共有 n(n+1)/2 个子数组。

- 空间复杂度：O(n)，其中 n 是数组的长度。空间复杂度取决于额外创建的数组 dp，如果不优化空间，则空间复杂度是 O(n^2)，使用一维数组优化之后空间复杂度可以降至 O(n)。
