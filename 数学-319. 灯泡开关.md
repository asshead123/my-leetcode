
## 题目地址(319. 灯泡开关)

https://leetcode-cn.com/problems/bulb-switcher/

## 题目描述

初始时有 n 个灯泡处于关闭状态。

对某个灯泡切换开关意味着：如果灯泡状态为关闭，那该灯泡就会被开启；而灯泡状态为开启，那该灯泡就会被关闭。

第 1 轮，每个灯泡切换一次开关。即，打开所有的灯泡。

第 2 轮，每两个灯泡切换一次开关。 即，每两个灯泡关闭一个。

第 3 轮，每三个灯泡切换一次开关。

第 i 轮，每 i 个灯泡切换一次开关。 而第 n 轮，你只切换最后一个灯泡的开关。

找出 n 轮后有多少个亮着的灯泡。

 

示例 1：

![](https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg)

```
输入：n = 3
输出：1 
解释：
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。


示例 2：

输入：n = 0
输出：0


示例 3：

输入：n = 1
输出：1


 

提示：

0 <= n <= 109
```

## 时间

- 2021年9月14日

## 难度

- 中等

## 思路
这个问题是这样描述的：有 n 盏电灯，最开始时都是关着的。现在要进行 n 轮操作：
- 第 1 轮操作是把每一盏电灯的开关按一下（全部打开）。
- 第 2 轮操作是把每两盏灯的开关按一下（就是按第 2，4，6... 盏灯的开关，它们被关闭）。
- 第 3 轮操作是把每三盏灯的开关按一下（就是按第 3，6，9... 盏灯的开关，有的被关闭，比如 3，有的被打开，比如 6）...

如此往复，直到第 n 轮，即只按一下第 n 盏灯的开关。

现在给你输入一个正整数 n 代表电灯的个数，问你经过 n 轮操作后，这些电灯有多少盏是亮的？

我们当然可以用一个布尔数组表示这些灯的开关情况，然后模拟这些操作过程，最后去数一下就能出结果。但是这样显得没有灵性，最好的解法是这样的：

**Java Code**

```java

class Solution {
    public int bulbSwitch(int n) {
        return (int)Math.sqrt(n);
    }
}

```

什么？这个问题跟平方根有什么关系？其实这个解法挺精妙，如果没人告诉你解法，还真不好想明白。

首先，因为电灯一开始都是关闭的，所以某一盏灯最后如果是点亮的，必然要被按奇数次开关。

我们假设只有 6 盏灯，而且我们只看第 6 盏灯。需要进行 6 轮操作对吧，请问对于第 6 盏灯，会被按下几次开关呢？这不难得出，第 1 轮会被按，第 2 轮，第 3 轮，第 6 轮都会被按。

为什么第 1、2、3、6 轮会被按呢？因为 6 = 1 * 6 = 2 * 3。一般情况下，因子都是成对出现的，也就是说开关被按的次数一般是偶数次。

但是有特殊情况，比如说总共有 16 盏灯，那么第 16 盏灯会被按几次?16 = 1 * 16 = 2 * 8 = 4 * 4。其中因子 4 重复出现，所以第 16 盏灯会被按 5 次，奇数次。

现在你应该理解这个问题为什么和平方根有关了吧？

**完全平方数的因子数是奇数个，非完全平方数的因子数是偶数个。**

不过，我们不是要算最后有几盏灯亮着吗，这样直接平方根一下是啥意思呢？稍微思考一下就能理解了。具有奇数个因子代表要切换开关奇数次，最后灯一定是亮的。假设有 n 盏灯，只要看 小于等于 n 的数中有几个完全平方数即可，计算方法就是 根号 n.
 
就假设现在总共有 16 盏灯，我们求 16 的平方根，等于 4，这就说明最后会有 4 盏灯亮着，它们分别是第 1 * 1 = 1 盏、第 2 * 2 = 4 盏、第 3 * 3 = 9 盏和第 4 * 4 = 16 盏。

就算有的 n 平方根结果是小数，强转成 int 型，也相当于一个最大整数上界，比这个上界小的所有整数，平方后的索引都是最后亮着的灯的索引。所以说我们直接把平方根转成整数，就是这个问题的答案。

