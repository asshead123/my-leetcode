
## 题目地址(10. 正则表达式匹配)

https://leetcode-cn.com/problems/regular-expression-matching/

## 题目描述

```
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

 

示例 1：

输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。


示例 2:

输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。


示例 3：

输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。


示例 4：

输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。


示例 5：

输入：s = "mississippi" p = "mis*is*p*."
输出：false

 

提示：

0 <= s.length <= 20
0 <= p.length <= 30
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符
```

# 时间

- 2021年8月27日

## 难度

- 困难

## 思路

### 方法：动态规划
点号通配符其实很好实现，`s`中的任何字符，只要遇到`.`通配符，无脑匹配就完事了。主要是这个星号通配符不好实现，一旦遇到`*`通配符，前面的那个字符可以选择重复一次，可以重复多次，也可以一次都不出现，这该怎么办？

对于这个问题，答案很简单，对于所有可能出现的情况，全部穷举一遍，只要有一种情况可以完成匹配，就认为`p`可以匹配`s`。那么一旦涉及两个字符串的穷举，我们就应该条件反射地想到动态规划的技巧了。

我们先脑补一下，`s`和`p`相互匹配的过程大致是，两个指针`i, j`分别在`s`和`p`上移动，如果最后两个指针都能移动到字符串的末尾，那么久匹配成功，反之则匹配失败。

**正则表达算法问题只需要把住一个基本点：看两个字符是否匹配，一切逻辑围绕匹配/不匹配两种情况展开即可。**

如果不考虑`*`通配符，面对两个待匹配字符`s[i]`和`p[j]`，我们唯一能做的就是看他俩是否匹配：

```java
bool isMatch(string s, string p) {
    int i = 0, j = 0;
    while (i < s.size() && j < p.size()) {
        // 「.」通配符就是万金油
        if (s[i] == p[j] || p[j] == '.') {
            // 匹配，接着匹配 s[i+1..] 和 p[j+1..]
            i++; j++;
        } else {
            // 不匹配
            return false;
        }
    }
    return i == j;
}
```

那么考虑一下，如果加入`*`通配符，局面就会稍微复杂一些，不过只要分情况来分析，也不难理解。

**当`p[j + 1]`为`\*`通配符时，我们分情况讨论下**：

1、如果匹配，即`s[i] == p[j]`，那么有两种情况：

1.1`p[j]`有可能会匹配多个字符，比如`s = "aaa", p = "a*"`，那么`p[0]`会通过`*`匹配 3 个字符`"a"`。

1.2`p[i]`也有可能匹配 0 个字符，比如`s = "aa", p = "a*aa"`，由于后面的字符可以匹配`s`，所以`p[0]`只能匹配 0 次。

2、如果不匹配，即`s[i] != p[j]`，只有一种情况：

`p[j]`只能匹配 0 次，然后看下一个字符是否能和`s[i]`匹配。比如说`s = "aa", p = "b*aa"`，此时`p[0]`只能匹配 0 次。

综上，可以把之前的代码针对`*`通配符进行一下改造：

```java
if (s[i] == p[j] || p[j] == '.') {
    // 匹配
    if (j < p.size() - 1 && p[j + 1] == '*') {
        // 有 * 通配符，可以匹配 0 次或多次
    } else {
        // 无 * 通配符，老老实实匹配 1 次
        i++; j++;
    }
} else {
    // 不匹配
    if (j < p.size() - 1 && p[j + 1] == '*') {
        // 有 * 通配符，只能匹配 0 次
    } else {
        // 无 * 通配符，匹配无法进行下去了
        return false;
    }
}
```

整体的思路已经很清晰了，但现在的问题是，遇到`*`通配符时，到底应该匹配 0 次还是匹配多次？多次是几次？

你看，这就是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」，**「状态」无非就是`i`和`j`两个指针的位置，「选择」就是`p[j]`选择匹配几个字符**。

根据「状态」，我们可以定义一个`dp`函数：

```java
boolean dp(String s, int i, String p, int j);
```

`dp`函数的定义如下：

**若`dp(s,i,p,j) = true`，则表示`s[i..]`可以匹配`p[j..]`；若`dp(s,i,p,j) = false`，则表示`s[i..]`无法匹配`p[j..]`**。

根据这个定义，我们想要的答案就是`i = 0,j = 0`时`dp`函数的结果，所以可以这样使用这个`dp`函数：

```java
bool isMatch(string s, string p) {
    // 指针 i，j 从索引 0 开始移动
    return dp(s, 0, p, 0);
```

可以根据之前的代码写出`dp`函数的主要逻辑：

```c
bool dp(string& s, int i, string& p, int j) {
    if (s[i] == p[j] || p[j] == '.') {
        // 匹配
        if (j < p.size() - 1 && p[j + 1] == '*') {
            // 1.1 通配符匹配 0 次或多次
            return dp(s, i, p, j + 2)
                || dp(s, i + 1, p, j);
        } else {
            // 1.2 常规匹配 1 次
            return dp(s, i + 1, p, j + 1);
        }
    } else {
        // 不匹配
        if (j < p.size() - 1 && p[j + 1] == '*') {
            // 2.1 通配符匹配 0 次
            return dp(s, i, p, j + 2);
        } else {
            // 2.2 无法继续匹配
            return false;
        }
    }
}
```

现在可以思考一下`dp`函数的 base case：

**一个 base case 是`j == p.size()`时**，按照`dp`函数的定义，这意味着模式串`p`已经被匹配完了，那么应该看看文本串`s`匹配到哪里了，如果`s`也恰好被匹配完，则说明匹配成功：

```c
if (j == p.size()) {
    return i == s.size();
}
```

**另一个 base case 是`i == s.size()`时**，按照`dp`函数的定义，这种情况意味着文本串`s`已经全部被匹配了，那么是不是只要简单地检查一下`p`是否也匹配完就行了呢？

```c
if (i == s.size()) {
    // 这样行吗？
    return j == p.size();
}
```

**这是不正确的，此时并不能根据`j`是否等于`p.size()`来判断是否完成匹配，只要`p[j..]`能够匹配空串，就可以算完成匹配**。比如说`s = "a", p = "ab*c*"`，当`i`走到`s`末尾的时候，`j`并没有走到`p`的末尾，但是`p`依然可以匹配`s`。

所以我们可以写出如下代码：

```c
int m = s.size(), n = p.size();

if (i == s.size()) {
    // 如果能匹配空串，一定是字符和 * 成对儿出现
    if ((n - j) % 2 == 1) {
        return false;
    }
    // 检查是否为 x*y*z* 这种形式
    for (; j + 1 < p.size(); j += 2) {
        if (p[j + 1] != '*') {
            return false;
        }
    }
    return true;
}
```

根据以上思路，就可以写出完整的代码：

```java
class Solution {
    Map<String, Boolean> memo;
    public boolean isMatch(String s, String p) {
        memo = new HashMap<>();
        return dp(s, 0, p, 0);
    }

    public boolean dp(String s, int i, String p, int j) {
        int m = s.length(), n = p.length();
        if (i == m) {
            if ((n - j) % 2 == 1)
                return false;
            for (; j + 1 < n; j += 2) {
                if (p.charAt(j+1) != '*')
                    return false;
            }
            return true;
        }
        if (j == n)
            return i == m;

        String key = i + "," + j;
        if (memo.containsKey(key)) return memo.get(key);

        boolean res = false;

        if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
            if (j + 1 < n && p.charAt(j + 1) == '*') {
                res = dp(s, i, p, j + 2) || dp(s, i + 1, p ,j);
            } else {
                res = dp(s, i + 1, p, j + 1);
            }
        } else {
            if (j + 1 < n && p.charAt(j + 1) == '*') {
                res = dp(s, i, p, j + 2);
            } else {
                res = false;
            }
        }
        memo.put(key, res);
        return res;
    }
}
```

代码中用了一个哈希表`memo`消除重叠子问题，因为正则表达算法的递归框架如下：

```c
bool dp(string& s, int i, string& p, int j) {
    dp(s, i, p, j + 2);     // 1
    dp(s, i + 1, p, j);     // 2
    dp(s, i + 1, p, j + 1); // 3
}
```

那么，如果让你从`dp(s, i, p, j)`得到`dp(s, i+2, p, j+2)`，至少有两条路径：`1 -> 2 -> 2`和`3 -> 3`，那么就说明`(i+2, j+2)`这个状态存在重复，这就说明存在重叠子问题。

动态规划的时间复杂度为「状态的总数」*「每次递归花费的时间」，本题中状态的总数当然就是`i`和`j`的组合，也就是`M * N`（`M`为`s`的长度，`N`为`p`的长度）；递归函数`dp`中没有循环（base case 中的不考虑，因为 base case 的触发次数有限），所以一次递归花费的时间为常数。二者相乘，总的时间复杂度为`O(MN)`。

空间复杂度很简单，就是备忘录`memo`的大小，即`O(MN)`。

