
## 题目地址(354. 俄罗斯套娃信封问题)

https://leetcode-cn.com/problems/russian-doll-envelopes/

## 题目描述

```
给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

注意：不允许旋转信封。

 

示例 1：

输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。

示例 2：

输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1


 

提示：

1 <= envelopes.length <= 5000
envelopes[i].length == 2
1 <= wi, hi <= 104
```

## 时间

- 2021年8月23日

## 难度

- 困难

## 思路

这道题目其实是最长递增子序列（Longes Increasing Subsequence，简写为 LIS）的一个变种，因为很显然，每次合法的嵌套是大的套小的，相当于找一个最长递增的子序列，其长度就是最多能嵌套的信封个数。

但是难点在于，标准的 LIS 算法只能在一维数组中寻找最长子序列，而我们的信封是由(w,h)这样的二维数对形式表示的，如何把 LIS 算法运用过来呢？

同时控制 w 和 h 两个维度并不是那么容易，因此我们考虑固定一个维度，再在另一个维度上进行选择。

这道题的解法是比较巧妙的：

**先对宽度 w 进行升序排序，如果遇到 w 相同的情况，则按照高度 h 降序排序。之后把所有的 h 作为一个数组，在这个数组上计算 LIS 的长度就是答案。**

对 w 升序排序，保证他们的宽度是可以相互嵌套的，而对于 w 相同的情况，如果我们不规定 h 值的排序顺序，那么可能会有如下的情况：

排完序的结果为 [(w, h)] = [(1, 1), (1, 2), (1, 3), (1, 4)]，由于这些信封的 w 值都相同，不存在一个信封可以装下另一个信封，那么我们只能在其中选择 1 个信封。然而如果我们完全忽略 w 维度，剩下的 h 维度为 [1, 2, 3, 4]，这是一个严格递增的序列，那么我们就可以选择所有的 4 个信封了，这就产生了错误。

因此，我们必须要保证**对于每一种 w 值，我们最多只能选择 1 个信封**。

我们可以将 h 值作为排序的第二关键字进行降序排序，这样一来，对于每一种 w 值，其对应的信封在排序后的数组中是按照 h 值递减的顺序出现的，那么这些 h 值不可能组成长度超过 1 的严格递增的序列，这就从根本上杜绝了错误的出现。

因此我们就可以得到解决本题需要的方法：

1. 首先我们将所有的信封按照 ww 值第一关键字升序、hh 值第二关键字降序进行排序；

2. 随后我们就可以忽略 ww 维度，求出 hh 维度的最长严格递增子序列，其长度即为答案。

下面简单提及两种计算最长严格递增子序列的方法，更详细的请参考[300. 最长递增子序列](https://github.com/asshead123/my-leetcode/blob/main/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md)题解。


### 方法一：动态规划
- 状态定义：
    - dp[i] 的值代表以 nums[i] 结尾的最长子序列长度。
- 转移方程： 每轮计算新 dp[i] 时，遍历 [0,i) 列表区间，做以下判断（设 j∈[0,i)）：
    1. 当 nums[i] > nums[j] 时： nums[i] 可以接在 nums[j] 之后（此题要求严格递增），此情况下最长上升子序列长度为 dp[j] + 1；
    2. 当 nums[i] <= nums[j] 时： nums[i] 无法接在 nums[j] 之后，此情况上升子序列不成立，跳过。
    - 转移方程： dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)。
- 初始状态：
    - dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
- 返回值：
    - 返回 dp 列表最大值，即可得到全局最长上升子序列长度。
- 复杂度分析：
    - 时间复杂度 O(N^2)： 遍历计算 dp 列表需 O(N)，计算每个 dp[i] 需 O(N)。
    - 空间复杂度 O(N) ： dp 列表占用线性大小额外空间。

**代码**

Java Code:

```java

class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, new Comparator<int []>(){
            public int compare(int[] a, int[] b) {
                return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];
            }
        });
        int[] height = new int[envelopes.length];
        for (int i = 0; i < envelopes.length; i++) {
            height[i] = envelopes[i][1];
        }
        return lengthOfLIS(height);
    }

    // 方法一：动态规划 求最长递增子序列长度
    public int lengthOfLIS0(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int res = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }

    // 方法二：二分查找 求最长递增子序列长度
    public int lengthOfLIS(int[] nums) {
        List<Integer> cell = new ArrayList<>();
        cell.add(nums[0]);
        for (int num: nums) {
            if (num > cell.get(cell.size() - 1)) {
                cell.add(num);
                continue;
            }
            int left = 0, right = cell.size() - 1;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (cell.get(mid) < num) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            cell.set(left, num);
        }
        return cell.size();
    }
}

```

### 方法二：基于二分查找的动态规划
### 方法二：动态规划+二分查找
- 很具小巧思。（比较难想！）
步骤如下：
1. 新建数组 cell，用于保存最长上升子序列。（即 cell 数组一直是递增的子序列）
2. 对原序列进行遍历，将每位元素二分插入 cell 中。
    - 如果 cell 中元素都比它小，将它插到最后
    - 否则，用它覆盖掉比它大的元素中最小的那个。（下面做解释）
总之，思想就是让 cell 中存储比较小的元素。这样，cell 未必是真实的最长上升子序列，但长度是对的。例如 [3, 4, 5, 1]这个序列，最终 cell 为 [1,4,5]，这不是一个解，但是长度是对的，也就是 cell 数组前面的元素会被更小的值更新，但丝毫不影响最终的最长子序列长度。

 举个栗子。你目前得到的最长递增是1245，然后进来一个3，把4替换掉，变成1,2,3,5，然后进来一个6，变成1,2,3,5,6，然后进来一个4，变成1,2,3,4,6。乍看之下好像其实可行的最长子序列是1,2,4,5,6，加了3或者加了4都不能是最长的。但次可行的最长子序列是1,2,3,4，而且1,2,3,4后续有可能会碰到比6更小的数，比如5，再把6覆盖掉。然后再碰到一个6，变成1,2,3,4,5,6，成为最长子序列。

换言之，你硬更新进去的数组，如果没有超出已有长度，那么它不影响你的计长，而如果超出了，那么它就会是新的可行的最长升序子序列，而且相比于你被覆盖掉的那个绝对最优。

- 复杂度分析：
    - 时间复杂度 O(NlogN)： 遍历 nums 列表需 O(N)，在每个 nums[i] 二分法需 O(logN)。
    - 空间复杂度 O(N) ： cell 列表占用线性大小额外空间。

