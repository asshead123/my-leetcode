
## 题目地址(11. 盛最多水的容器)

https://leetcode-cn.com/problems/container-with-most-water/

## 题目描述

```
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

 

示例 1：

输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

示例 2：

输入：height = [1,1]
输出：1


示例 3：

输入：height = [4,3,2,1,4]
输出：16


示例 4：

输入：height = [1,2,1]
输出：2


提示：

n = height.length
2 <= n <= 3 * 104
0 <= height[i] <= 3 * 104
```

## 时间

- 2021年8月2日

## 思路

### 方法一：双指针
一开始，我们先去考虑相距最远的两个柱子所能容纳水的面积。
![](https://blog-1257126549.cos.ap-guangzhou.myqcloud.com/blog/0gwk7.jpg)

接下来去思考，我们去移动哪根柱子会更加合适?

如果高柱子向内移动，那么宽度一定减少，高度也一定不会增加，这样水的面积一定减少。

如果矮柱子向内移动，那么宽度一定减少，高度有可能会增加，这样水的面积有可能更大。

结论：移动两根柱子之间更短的那根柱子，才有可能在宽度一定变小的情况下，找到一个更高的水面，从而使得面积有可能更大。

因此，得出算法步骤如下：

1、设置两个索引，分别指向容器的两侧，即索引 left 指向最左边的柱子，索引 right 指向最右边的柱子。

2、记录下此时的水的面积，可以定义为 res

3、观察需要向内移动哪根柱子

1）如果移动较高的柱子，由于水的宽度在变小，而水的高度一定不会增加，所以最终水的面积不会超过之前记录的水的面积 res

2）所以，只能移动较短的柱子，然后计算此时水的面积，再与之前记录的水的面积 res 进行比较，保存那个更大的值

4、接下来接续判断应该向内移动哪根柱子

5、直到 left 和 right 相遇为止

Java Code:

```java

class Solution {
    public int maxArea(int[] height) { 
        int n = height.length;
        int left = 0, right = n - 1;
        int res = 0;
        while (left < right) {
            int area = (right - left) * Math.min(height[left], height[right]);
            if (area > res) {
                res = area;
            }
            if(height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return res;
    }
}

```


**复杂度分析**

- 时间复杂度：`O(N)`，双指针总计最多遍历整个数组一次。

- 空间复杂度：`O(1)`，只需要额外的常数级别的空间。


