
## 题目地址(371. 两整数之和)

https://leetcode-cn.com/problems/sum-of-two-integers/

## 题目描述

```
给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。

 

示例 1：

输入：a = 1, b = 2
输出：3


示例 2：

输入：a = 2, b = 3
输出：5


 

提示：

-1000 <= a, b <= 1000
```

## 时间

- 2021年9月26日（每日一题）

## 难度

- 中等

## 思路

### 方法一：位运算

一个朴素的做法是使用「位运算」，利用二进制的「逢二进一」和「int 二进制表示长度为 32」，我们可以从低位往高位进行处理，处理过程中使用变量 t 记录进位信息。

**Java Code:**

```java

class Solution {
    public int getSum(int a, int b) {
        int ans = 0;
        for (int i = 0, t = 0; i < 32; i++) {
            // 取 a,b 第i位的二进制数字
            int u1 = (a >> i) & 1, u2 = (b >> i) & 1;
            
            if (u1 == 1 && u2 == 1) {
                // u1=1 && u2=1
                // 结果看上一位的进位，并置进位t为1
                ans |= (t << i);
                t = 1;
            } else if (u1 == 1 || u2 == 1) {
                // u1=1 || u2=1:
                // 若上一位的进位t=1,则结果为0，即((1 ^ t) << i)，进位t仍为1
                // 若上一位的进位t=0,则结果为1，即((1 ^ t) << i)，进位t仍为0
                ans |= ((1 ^ t) << i);
            } else {
                // u1 = 0 && u2 = 0
                // 结果看上一位的进位，并置进位t为0
                ans |= (t << i);
                t = 0;
            }
        }
        return ans;
    }
}

```


**复杂度分析**

- 时间复杂度：O(C)，C为常数，固定为 32
- 空间复杂度：O(1)

### 方法二：递归
在彻底理解「解法一」后，不难发现「解法一」中本质是分别对两数的当前位进行“拆分”求解。

先计算原始的 a 的和原始 b 在不考虑进位的情况下的结果，结果为 a ^ b，然后在此基础上，考虑将进位累加进来，累加操作可以递归使用 getSum 来处理。

问题转化为如何求得 a 和 b 的进位值。

不难发现，当且仅当 a 和 b 的当前位均为 1，该位才存在进位，同时进位会应用到当前位的下一位（左边的一边，高一位），因此最终的进位结果为 (a & b) << 1。

因此，递归调用 getSum(a ^ b, (a & b) << 1) 我们可以得到最终答案。

最后还要考虑，该拆分过程何时结束。

由于在进位结果 (a & b) << 1 中存在左移操作，因此最多执行 32 次的递归操作之后，该值会变为 0，而 0 与任何值 x 相加结果均为 x。

```java
class Solution {
    public int getSum(int a, int b) {
        return b == 0 ? a : getSum(a ^ b, (a & b) << 1);
    }
}
```

**复杂度分析**

- 时间复杂度：O(C)，C为常数，固定为 32。最多执行 C 次的 (a & b) << 1，递归过程结束。
- 空间复杂度：O(1)
