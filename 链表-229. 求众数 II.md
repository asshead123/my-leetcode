
## 题目地址(229. 求众数 II)

https://leetcode-cn.com/problems/majority-element-ii/

## 题目描述

```
给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

 

 

示例 1：

输入：[3,2,3]
输出：[3]

示例 2：

输入：nums = [1]
输出：[1]


示例 3：

输入：[1,1,1,3,3,2,2,2]
输出：[1,2]

 

提示：

1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109

 

进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。
```

## 前置知识

- 

## 公司

- 暂无

## 思路

### 方法一：哈希表

这道题用 map 方法去做很简单，直接给出代码。
```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        int n = nums.length;
        n /= 3;
        Map<Integer, Integer> map = new HashMap<>();
        List<Integer> list = new ArrayList();
        for (int i = 0; i < nums.length; i++) {
            map.putIfAbsent(nums[i], 0);
            if (map.get(nums[i]) > n)
                continue;
            
            if (map.get(nums[i]) == n)
                list.add(nums[i]);
            map.put(nums[i], map.get(nums[i]) + 1);
            
        }
        return list;
    }
}
```
**复杂度分析**

- 时间复杂度：O(n)，其中 n 为数组的长度。
-  空间复杂度：O(n)，其中 n 为数组的长度，使用哈希表需要开辟额外的空间。。

### 方法二：摩尔投票法

题目描述要求要达到线性的时间复杂度，还有常量级的空间复杂度。因此选择摩尔投票法。

先介绍摩尔投票法的原理。

摩尔投票法，解决的问题是如何在任意多的候选人中，选出票数超过一半的那个人。注意，是超出一半票数的那个人。

假设投票是这样的，[A, C, A, A, B]，ABC 是指三个候选人。

第一张票与第二张票进行对坑，如果票不同则互相抵消掉；

接着第三票与第四票进行对坑，如果票相同，则增加这个候选人的可抵消票数；

这个候选人拿着可抵消票数与第五张票对坑，如果票不同，则互相抵消掉，即候选人的可抵消票数 -1。

举例：
```
[A,    B,    C,    B,    A,    A,    A]
[A,1],[A,0],[C,1],[C,0],[A,1],[A,2],[A,3]
```
看完上面的例子之后，相信已经理解摩尔投票法是如何选取一个最有希望的候选人的。

但这不意味着这个候选人的票数一定能超过一半，例如 [A, B, C] 的抵消阶段，最后得到的结果是 [C,1]，C 候选人的票数也未能超过一半的票数。

但是俺在这里发现了一个优化，如果最后得到的可抵消票数是 0 的话，那他已经无缘票数能超过一半的那个人了。因为本来可能有希望的，但是被后面的一张不同的票抵消掉了。所以，在这里可以直接返回结果，无需后面的计算了。

如果最后得到的抵消票数不为 0 的话，那说明他可能希望的，这是我们需要一个阶段来验证这个候选人的票数是否超过一半—— 计数阶段。

所以摩尔投票法分为两个阶段：抵消阶段和计数阶段。

抵消阶段：两个不同投票进行对坑，并且同时抵消掉各一张票，如果两个投票相同，则累加可抵消的次数；

计数阶段：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定。

摩尔投票法经历两个阶段最多消耗 O(2n) 的时间，也属于 O(n) 的线性时间复杂度，另外空间复杂度也达到常量级。

理解摩尔投票法之后，我们再回到题目描述，题目可以看作是：在任意多的候选人中，选出票数超过⌊ 1/3 ⌋的候选人。

我们可以这样理解，假设投票是这样的 [A, B, C, A, A, B, C]，ABC 是指三个候选人。

第 1 张票，第 2 张票和第3张票进行对坑，如果票都不同，则互相抵消掉；

第 4 张票，第 5 张票和第 6 张票进行对坑，如果有部分相同，则累计增加他们的可抵消票数，如 [A, 2] 和 [B, 1]；

接着将 [A, 2] 和 [B, 1] 与第 7 张票进行对坑，如果票都没匹配上，则互相抵消掉，变成 [A, 1] 和 [B, 0] 。

看下面例子，就知道什么回事了。

```
            [A,    B,    B,    C,    B,    C,    A,    A]
cnad1:[A,0],[A,1],[A,1],[A,1],[A,0],[A,0],[C,1],[C,0],[A,1]
cand2:[A,0]       [B,1],[B,2],[B,1],[B,2],[B,2],[B,1],[B,1]
      初始化             都没投到票，都抵消
```

然后按照这个思路来进行编程。但贴代码之前，先来一个归纳。

如果至多选一个代表，那他的票数至少要超过一半（⌊ 1/2 ⌋）的票数；

如果至多选两个代表，那他们的票数至少要超过 ⌊ 1/3 ⌋ 的票数；

如果至多选m个代表，那他们的票数至少要超过 ⌊ 1/(m+1) ⌋ 的票数。

所以以后碰到这样的问题，而且要求达到线性的时间复杂度以及常量级的空间复杂度，直接套上摩尔投票法。

**Java Code:**

```java

class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> res = new ArrayList();
        if (nums == null || nums.length == 0) return res;
        // 初始化两个候选人candidate，和他们的计票
        int cand1 = nums[0], vote1 = 0;
        int cand2 = nums[0], vote2 = 0;
        // 配对阶段
        for (int num: nums) {
            if (vote1 > 0 && num == cand1) { //如果该元素为第一个元素，则计数加1
                vote1++;
            } else if (vote2 > 0 && num == cand2) { //如果该元素为第二个元素，则计数加1
                vote2++;
            } else if (vote1 == 0) { // 选择第一个元素
                cand1 = num;
                vote1++;
            } else if (vote2 == 0) { // 选择第二个元素
                cand2 = num;
                vote2++;
            } else { //如果三个元素均不相同，则相互抵消1次
                vote1--;
                vote2--;
            }                
        }
        // 计数阶段
        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3
        int cnt1 = 0;
        int cnt2 = 0;
        for (int num: nums) {
            if (vote1 > 0 && num == cand1) cnt1++;
            else if (vote2 > 0 && num == cand2) cnt2++; 
        }
        if (vote1 > 0 && cnt1 > nums.length / 3) res.add(cand1);
        if (vote2 > 0 && cnt2 > nums.length / 3) res.add(cand2);
        return res;
    }
}

```


**复杂度分析**
- 时间复杂度：O(n)，其中 n 为数组的长度。
-  空间复杂度：O(1)，只需要常数个元素用来存储关键元素和统计次数即可。


