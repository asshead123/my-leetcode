
## 题目地址(316. 去除重复字母)

https://leetcode-cn.com/problems/remove-duplicate-letters/

## 题目描述

```
给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同

 

示例 1：

输入：s = "bcabc"
输出："abc"


示例 2：

输入：s = "cbacdcbc"
输出："acdb"

 

提示：

1 <= s.length <= 104
s 由小写英文字母组成
```

## 时间

- 2021年8月7日

## 前置知识

**字典序**：按照单词出现在字典的顺序比较两个字符串的方法。例如：“abc”的字典序在“acdb”的前面。

首先比较第 1 个字符的 ASCII 码：

如果不同，则第 1 个字符 ASCII 码较小的字符，整体字典序更靠前；

如果相同，则继续比较第 2 个字符，……

如此继续，比较整个字符串的大小。

## 思路

方法一：单调栈

题目的要求总结出来有三点：

要求一、要去重。

要求二、去重字符串中的字符顺序不能打乱 s 中字符出现的相对顺序。

要求三、在所有符合上一条要求的去重字符串中，字典序最小的作为最终结果。


观察示例 1：bcabc。

- 字符 a 在字符串中只出现一次，根据题目要求，字符 a 必须被选取；
- 字符 b 出现了两次，显然选择 a后面的那个 b。因为 字典序 ab 靠前，ba 靠后。同理，相同的字符 c ，我们选择后一个 c。因此，输出是 abc。

选出 abc 可以从左到右遍历一次字符串：

第 ① 步：看到 b，只有一个字符，暂时保存起来；

第 ② 步：看到 c，bc 是单调递增的，已经是字典序最小的，暂时保存起来；

第 ③ 步：看到 a，a 的字典序比之前看到的 b 和 c 都靠前，因此应该 想办法让 a 的位置往前靠，ASCII 值越小的字母越靠前，整体字符串的字典序就更靠前，这件事情等价于，先看看最近看到的 c 以后会不会出现，c 以后还会出现，因此可以舍弃 c ，再看看最早看到的 b 在以后会不会出现，b 以后还会出现，因此可以舍弃 b，此时 a 前面没有读到的字典了。b 比 c 先读到，而比 c 后丢弃，因此解决这个问题可以使用 「后进先出」的数据结构：栈。

再观察示例 2：cbacdcbc。

一共出现 4 种字符：a、b、c、d。

其中 a 和 d 只出现一次，必须被选取；

b 出现 2 次，一个在 a 前面，一个在 a 后面，显然保留在 a 后面的；

c 出现 4 次。

下面的示意图展示了程序的执行流程，请大家注意第 ⑥ 步和第 ⑧ 步的分析。

![](https://pic.leetcode-cn.com/1603768499-DmVdis-image.png)

第 ① 步：读到 c，入栈，此时栈中元素 [c]；

第 ② 步：读到 b，b 的字典序比之前的 c 小，c 在以后还会出现，因此 c 出栈，b 入栈，此时栈中元素 [b]；

第 ③ 步：读到 a，a 的字典序比之前的 b 小，b 在以后还会出现，因此 b 出栈，a 入栈，此时栈中元素 [a]；

第 ④ 步：读到 c，c 的字典序比之前的 a 大，直接让 c 入栈，此时栈中元素 [a, c]；

第 ⑤ 步：读到 d，d 的字典序比之前的 d 大，直接让 d 入栈，此时栈中元素 [a, c, d]；

第 ⑥ 步：读到 c，此时栈中已经有 c，题目要求不能有重复字符，所以舍弃当前看到的 c ，注意：如果当前遍历到栈中已经有的字符，可以舍弃当前遍历到的重复字符。原因放在第 ⑧ 步说；

第 ⑦ 步：读到 b，b 的字典序比之前的 d 小，但是后面不会再出现 d ，因此 b 就应该放在这个位置，因此让 b 入栈，此时栈中元素 [a, c, d, b]；

第 ⑧ 步：读到 c，下面我们证明：如果遍历到当前栈中已经有的字符，可以舍弃当前遍历到的字符。

**如果遍历到当前栈中已经有的字符，可以舍弃当前遍历到的字符**

在例 2 分析的第 ⑧ 步，此时栈中元素为 [a, c, d, b]，可以看成两个部分，第一个部分是 [a, c, d] ，第二个部分是 [b]，这两个部分分别是按照字典序升序排列的。

之所以会造成 分段单调递增 的现象，是因为 某个单调递增段的最后一个元素，在以后不会再遍历到，而题目又要求我们保持选取字母的相对顺序，因此 某个单调递增段的最后一个元素 必需被放置在现在放置的位置。

（反证）如果接下来还会遍历到 d 那么按照之前设计的算法逻辑，我们会丢弃第 1 个 d 而让 b 靠前，这样得到的字典序的子段 bd 更小。

再接着例 2 的第 ⑧ 步说，既然已经出现在栈中的元素，不可能是 某个单调递增段的最后一个元素，因此如果丢弃之前遇到的那个相同字符，它紧挨着的下一个字符的 ASCII 值更大。ASCII 值更大的字符靠前一位，整体字典序更大。因此应该丢弃当前遇到的相同字符。


**代码**

Java Code:

```java

class Solution {
    public String removeDuplicateLetters(String s) {
        // 存放去重的结果
        Stack<Character> stack= new Stack<>();
        // 布尔数组初始值为 false，记录栈中是否存在某个字符
        boolean[] inStack = new boolean[256];
        // 计数器记录字符串中字符的数量
        int[] count = new int[256];
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            count[c]++;
        }

        // 转成字符数组是因为，s.charAt(i) 会检查字符串的下标是否越界，事实上没有必要
        // 遍历字符串之前，先转换成字符数组是常见的做法
        for (char c : s.toCharArray()) {
            count[c]--;
            // 如果字符 c 存在栈中，直接跳过
            if(inStack[c]) continue;

            while (!stack.isEmpty() && stack.peek() > c) {
                if (count[stack.peek()] == 0) {
                    break;
                }
                inStack[stack.pop()] = false;
            }
            stack.push(c);
            inStack[c] = true;
        }
        StringBuilder sb = new StringBuilder();
        while (!stack.empty()) {
            sb.append(stack.pop());
        }
        return sb.reverse().toString();
    }
}

```

你还记得我们开头提到的三个要求吗？我们是怎么达成这三个要求的？

要求一、通过 inStack 这个布尔数组做到栈中不存在重复元素。

要求二、我们顺序遍历字符串s，通过「栈」这种顺序结构的 push/pop 操作记录结果字符串，保证了字符出现的顺序和 s 中出现的顺序一致。

这里也可以想到为什么要用「栈」这种数据结构，因为先进后出的结构允许我们立即操作刚插入的字符，如果用「队列」的话肯定是做不到的。

要求三、我们用类似单调栈的思路，配合计数器count不断 pop 掉不符合最小字典序的字符，保证了最终得到的结果字典序最小。

当然，由于栈的结构特点，我们最后需要把栈中元素取出后再反转一次才是最终结果。


**复杂度分析**

- 时间复杂度：`O(N)`，这里 `N` 是字符的长度；
- 空间复杂度：`O(N) `，最坏情况下，这个字符串本身就是字典序最小的字符串，栈中就要存字符串长度这么多的字符串。


