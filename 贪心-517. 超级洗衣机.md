
## 题目地址(517. 超级洗衣机)

https://leetcode-cn.com/problems/super-washing-machines/

## 题目描述


假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。

在每一步操作中，你可以选择任意 m (1 <= m <= n) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。

给定一个整数数组 machines 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 最少的操作步数 。如果不能使每台洗衣机中衣物的数量相等，则返回 -1 。

 

示例 1：
```
输入：machines = [1,0,5]
输出：3
解释：
第一步:    1     0 <-- 5    =>    1     1     4
第二步:    1 <-- 1 <-- 4    =>    2     1     3    
第三步:    2     1 <-- 3    =>    2     2     2   
```

示例 2：
```
输入：machines = [0,3,0]
输出：2
解释：
第一步:    0 <-- 3     0    =>    1     2     0    
第二步:    1     2 --> 0    =>    1     1     1     
```

示例 3：
```
输入：machines = [0,2,0]
输出：-1
解释：
不可能让所有三个洗衣机同时剩下相同数量的衣物。
```

 

提示：
```
n == machines.length
1 <= n <= 10^4
0 <= machines[i] <= 10^5
```

## 时间

- 2021年9月29日（每日一题）

## 难度

- 困难

## 思路：贪心

显然，如果洗衣机的数量 不能整除 所有洗衣机的衣服之和，则不能使每台洗衣机中衣物的数量相等。

反之，都可以使每台洗衣机中衣物的数量相等。

每台洗衣机，每次只能将一件衣服送到相邻的一台洗衣机。

题目要求传递次数最少：那么可以保证衣服较多的洗衣机足够聪明，它知道该向左还是向右传递多出来的衣服；否则的话，传递出去的衣服会重新穿回自己的手里，还得再丢出去一次

设 num 为洗衣机初始的衣服数量，Avg 为最后每台洗衣机中衣物的数量相等的数量。

- 因为每次只能移动一件衣服，所以对于每个洗衣机，最少需要 num - Avg 次转移。
- 因为每次只能往相邻的洗衣机转移一件衣服，所以假设前 i 个洗衣机的衣服总和为 presum，那么至少需要 |presum - i * Avg| 次转移，才能使 前 i个 和 前 i 个后面 洗衣机中的衣服相等。若 presum - i * Avg > 0 则表示 前 i 个洗衣机的衣服，需要向 前i个洗衣机后面里 转移；若 presum - i * Avg <= 0 则表示 前 i 个后面的洗衣机的衣服，需要向 前 i 个洗衣机里 转移。

两者情况取最大值。

```
machines = [7,6,5,4,3,2,1]
avg = 4
从左往右遍历数组，使用变量标记当前值是溢出还是不足
初始  7 6 5 4 3 2 1
迭代  3 5 6 6 5 3 0
可见，[7,6,5] 溢出的值会一直累加，这些值会在 4 处开始释放，因此结果为 6

同理，若数组是降序：
machines = [1,2,3,4,5,6,7]
avg = 4
初始   1   2   3   4   5   6   7
迭代  -3  -5  -6  -6  -5  -3   0
只需要取绝对值即可，结果为 6

一种特殊情况是，每个点每次只能释放 1：
machines = [0, 3, 0]
avg = 1
初始   0  3  0
迭代  -1  1  0

直接计算的结果是 1，原因是在 3 处同时向左、右释放值，这是不允许的，
因此在迭代过程中需要给结果一个下界 (num - avg)，以规定最少释放次数
```


**Java Code:**

```java

class Solution {
    public int findMinMoves(int[] machines) {
        int sum = 0, presum = 0, ans = 0;
        int n = machines.length;
        for (int i : machines) sum += i;
        if (sum % n != 0) return -1;
        int avg = sum / n;
        for (int i = 0; i < n; i++) {
            presum += machines[i];
            ans = Math.max(ans, Math.max(machines[i] - avg, Math.abs(presum - avg * (i + 1))));
        }
        return ans;
    }
}

```


**复杂度分析**

令 n 为数组长度。

- 时间复杂度：O(n)。
- 空间复杂度：O(1)。


