
## 题目地址(650. 只有两个键的键盘)

https://leetcode-cn.com/problems/2-keys-keyboard/

## 题目描述

```
最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：

Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
Paste（粘贴）：粘贴 上一次 复制的字符。

给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。

 

示例 1：

输入：3
输出：3
解释：
最初, 只有一个字符 'A'。
第 1 步, 使用 Copy All 操作。
第 2 步, 使用 Paste 操作来获得 'AA'。
第 3 步, 使用 Paste 操作来获得 'AAA'。


示例 2：

输入：n = 1
输出：0


 

提示：

1 <= n <= 1000
```

## 时间

- 2021年9月19日（每日一题）

## 难度

- 中等

## 思路

### 方法一：分解质因数（推荐）

首先我们写前几个函数值并观察规律：
- 1 - 0
- 2 - 2
- 3 - 3
- 4 - 4
- 5 - 5
- 6 - 5
- 7 - 7
- 8 - 6

**结论 1 ：f(2 * n) = f(n) + 2.**

这是因为我们需要先通过 f(n) 次操作得到 n，再复制、粘贴(2步)得到 2 * n.

**结论 2 ：对于质数 p，f(p) = p.**

这是因为要达到 p，只有复制 1，再粘贴 p - 1 次.

从以上两个结论得到启发，我们考虑一个合数 n = p1 * p2 （p1，p2为质数）的达到方式，有三种途径可以达到 n:

1. 1 -> p1 * p2，即复制1，再粘贴 p1 * p2 - 1 次，共操作 p1 * p2 次 
2. 1 -> p1 -> p1 * p2，即复制1，粘贴 p1 - 1 次，再复制p1，粘贴 p2 - 1 次，共操作 1 + p1 - 1 + 1 + p2 - 1 = p1 + p2 次 
3. 1 -> p2 -> p1 * p2，即复制1，粘贴 p2 - 1 次，再复制p2，粘贴 p1 - 1 次，共操作 1 + p2 - 1 + 1 + p1 - 1 = p1 + p2 次 

由于p1 + p2 < p1 * p2， 所以，f(p1 * p2) = p1 + p2.

从而，我们很容易推导出，若 n = p1 * p2 * ... * pi，其中 pi 为质数，则

f(n) = p1 + p2 + ... + pi.

进一步地，若 n = p1^r1 * p2^r2 * ... * pi^ri，其中 pi 为质数，ri >= 1，则

f(n) = p1 * r1 + p2 * r2 + ... + pi * ri.

也就是对 n 做质因数分解，并将所有质因数乘以它的幂次并相加即可.

**Java Code**

```java

class Solution {
    public int minSteps(int n) {
        int res = 0, m = n;
        for (int i = 2; i <= n; i++) {
            while (m % i == 0) {
                res += i;
                m /= i;
            }
        }
        return res;
    }
}

```

### 方法二：动态规划
定义 f[i][j] 为经过最后一次操作后，当前记事本上有 i 个字符，粘贴板上有 j 个字符的最小操作次数。

由于我们粘贴板的字符必然是经过 Copy All 操作而来，因此对于一个合法的 f[i][j] 而言，必然有 j <= i。

不失一般性地考虑 f[i][j] 该如何转移：

- 最后一次操作是 Paste 操作：此时粘贴板的字符数量不会发生变化，即有 f[i][j] = f[i - j][j] + 1；

- 最后一次操作是 Copy All 操作：那么此时的粘贴板的字符数与记事本上的字符数相等（满足 i = j），此时的 f[i][j] = min(f[i][x]+1),0≤x<i。

我们发现最后一个合法的 f[i][i]依赖与前面 f[i][j]（满足 j < i）。

因此实现上，我们可以使用一个变量 min 保存前面转移的最小值，用来更新最后的 f[i][j]。

再进一步，我们发现如果 f[i][j] 的最后一次操作是由 Paste 而来，原来粘贴板的字符数不会超过 i / 2，因此在转移 f[i][j]（满足 j < i）时，其实只需要枚举 [0, i/2] 即可。

```java
class Solution {
    int INF = 0x3f3f3f3f;
    public int minSteps(int n) {
        int[][] f = new int[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                f[i][j] = INF;
            }
        }
        f[1][0] = 0; f[1][1] = 1;
        for (int i = 2; i <= n; i++) {
            int min = INF;
            for (int j = 0; j <= i / 2; j++) {
                f[i][j] = f[i - j][j] + 1;
                min = Math.min(min, f[i][j]);
            }
            f[i][i] = min + 1;
        }
        int ans = INF;
        for (int i = 0; i <= n; i++) ans = Math.min(ans, f[n][i]);
        return ans;
    }
}
```
**复杂度分析**

- 时间复杂度：O(n^2)
- 空间复杂度：O(n^2)

